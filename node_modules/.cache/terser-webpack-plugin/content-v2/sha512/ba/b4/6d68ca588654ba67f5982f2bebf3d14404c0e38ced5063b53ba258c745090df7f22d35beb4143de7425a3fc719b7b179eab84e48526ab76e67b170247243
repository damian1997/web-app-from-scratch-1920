{"code":"!function(t){var n={};function e(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return t[r].call(a.exports,a,a.exports,e),a.l=!0,a.exports}e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:r})},e.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(e.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&n&&\"string\"!=typeof t)for(var a in t)e.d(r,a,function(n){return t[n]}.bind(null,a));return r},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,\"a\",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p=\"\",e(e.s=3)}([function(module,exports,__webpack_require__){eval(\"/*!\\n * routie - a tiny hash router\\n * v0.3.2\\n * http://projects.jga.me/routie\\n * copyright Greg Allen 2016\\n * MIT License\\n*/\\nvar Routie = function(w, isModule) {\\n\\n  var routes = [];\\n  var map = {};\\n  var reference = \\\"routie\\\";\\n  var oldReference = w[reference];\\n\\n  var Route = function(path, name) {\\n    this.name = name;\\n    this.path = path;\\n    this.keys = [];\\n    this.fns = [];\\n    this.params = {};\\n    this.regex = pathToRegexp(this.path, this.keys, false, false);\\n\\n  };\\n\\n  Route.prototype.addHandler = function(fn) {\\n    this.fns.push(fn);\\n  };\\n\\n  Route.prototype.removeHandler = function(fn) {\\n    for (var i = 0, c = this.fns.length; i < c; i++) {\\n      var f = this.fns[i];\\n      if (fn == f) {\\n        this.fns.splice(i, 1);\\n        return;\\n      }\\n   }\\n  };\\n\\n  Route.prototype.run = function(params) {\\n    for (var i = 0, c = this.fns.length; i < c; i++) {\\n      this.fns[i].apply(this, params);\\n    }\\n  };\\n\\n  Route.prototype.match = function(path, params){\\n    var m = this.regex.exec(path);\\n\\n    if (!m) return false;\\n\\n\\n    for (var i = 1, len = m.length; i < len; ++i) {\\n      var key = this.keys[i - 1];\\n\\n      var val = ('string' == typeof m[i]) ? decodeURIComponent(m[i]) : m[i];\\n\\n      if (key) {\\n        this.params[key.name] = val;\\n      }\\n      params.push(val);\\n    }\\n\\n    return true;\\n  };\\n\\n  Route.prototype.toURL = function(params) {\\n    var path = this.path;\\n    for (var param in params) {\\n      path = path.replace('/:'+param, '/'+params[param]);\\n    }\\n    path = path.replace(/\\\\/:.*\\\\?/g, '/').replace(/\\\\?/g, '');\\n    if (path.indexOf(':') != -1) {\\n      throw new Error('missing parameters for url: '+path);\\n    }\\n    return path;\\n  };\\n\\n  var pathToRegexp = function(path, keys, sensitive, strict) {\\n    if (path instanceof RegExp) return path;\\n    if (path instanceof Array) path = '(' + path.join('|') + ')';\\n    path = path\\n      .concat(strict ? '' : '/?')\\n      .replace(/\\\\/\\\\(/g, '(?:/')\\n      .replace(/\\\\+/g, '__plus__')\\n      .replace(/(\\\\/)?(\\\\.)?:(\\\\w+)(?:(\\\\(.*?\\\\)))?(\\\\?)?/g, function(_, slash, format, key, capture, optional){\\n        keys.push({ name: key, optional: !! optional });\\n        slash = slash || '';\\n        return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')' + (optional || '');\\n      })\\n      .replace(/([\\\\/.])/g, '\\\\\\\\$1')\\n      .replace(/__plus__/g, '(.+)')\\n      .replace(/\\\\*/g, '(.*)');\\n    return new RegExp('^' + path + '$', sensitive ? '' : 'i');\\n  };\\n\\n  var addHandler = function(path, fn) {\\n    var s = path.split(' ');\\n    var name = (s.length == 2) ? s[0] : null;\\n    path = (s.length == 2) ? s[1] : s[0];\\n\\n    if (!map[path]) {\\n      map[path] = new Route(path, name);\\n      routes.push(map[path]);\\n    }\\n    map[path].addHandler(fn);\\n  };\\n\\n  var routie = function(path, fn) {\\n    if (typeof fn == 'function') {\\n      addHandler(path, fn);\\n      routie.reload();\\n    } else if (typeof path == 'object') {\\n      for (var p in path) {\\n        addHandler(p, path[p]);\\n      }\\n      routie.reload();\\n    } else if (typeof fn === 'undefined') {\\n      routie.navigate(path);\\n    }\\n  };\\n\\n  routie.lookup = function(name, obj) {\\n    for (var i = 0, c = routes.length; i < c; i++) {\\n      var route = routes[i];\\n      if (route.name == name) {\\n        return route.toURL(obj);\\n      }\\n    }\\n  };\\n\\n  routie.remove = function(path, fn) {\\n    var route = map[path];\\n    if (!route)\\n      return;\\n    route.removeHandler(fn);\\n  };\\n\\n  routie.removeAll = function() {\\n    map = {};\\n    routes = [];\\n  };\\n\\n  routie.navigate = function(path, options) {\\n    options = options || {};\\n    var silent = options.silent || false;\\n\\n    if (silent) {\\n      removeListener();\\n    }\\n    setTimeout(function() {\\n      window.location.hash = path;\\n\\n      if (silent) {\\n        setTimeout(function() { \\n          addListener();\\n        }, 1);\\n      }\\n\\n    }, 1);\\n  };\\n\\n  routie.noConflict = function() {\\n    w[reference] = oldReference;\\n    return routie;\\n  };\\n\\n  var getHash = function() {\\n    return window.location.hash.substring(1);\\n  };\\n\\n  var checkRoute = function(hash, route) {\\n    var params = [];\\n    if (route.match(hash, params)) {\\n      route.run(params);\\n      return true;\\n    }\\n    return false;\\n  };\\n\\n  var hashChanged = routie.reload = function() {\\n    var hash = getHash();\\n    for (var i = 0, c = routes.length; i < c; i++) {\\n      var route = routes[i];\\n      if (checkRoute(hash, route)) {\\n        return;\\n      }\\n    }\\n  };\\n\\n  var addListener = function() {\\n    if (w.addEventListener) {\\n      w.addEventListener('hashchange', hashChanged, false);\\n    } else {\\n      w.attachEvent('onhashchange', hashChanged);\\n    }\\n  };\\n\\n  var removeListener = function() {\\n    if (w.removeEventListener) {\\n      w.removeEventListener('hashchange', hashChanged);\\n    } else {\\n      w.detachEvent('onhashchange', hashChanged);\\n    }\\n  };\\n  addListener();\\n\\n  if (isModule){\\n    return routie;\\n  } else {\\n    w[reference] = routie;\\n  }\\n   \\n};\\n\\nif (false){} else {\\n  module.exports = Routie(window,true);\\n} \\n\\n\\n//# sourceURL=webpack:///./src/js/libraries/routie.js?\")},function(module,exports,__webpack_require__){eval(\"// extracted by mini-css-extract-plugin\\n\\n//# sourceURL=webpack:///./src/scss/main.scss?\")},,function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n\\n// EXTERNAL MODULE: ./src/scss/main.scss\\nvar main = __webpack_require__(1);\\n\\n// EXTERNAL MODULE: ./src/js/libraries/routie.js\\nvar routie = __webpack_require__(0);\\nvar routie_default = /*#__PURE__*/__webpack_require__.n(routie);\\n\\n// CONCATENATED MODULE: ./src/js/components/api.js\\nasync function getForkers(baseUrl,forkedRepoOwner,forkedRepo) {\\n\\tconst data = await fetch(`${baseUrl}/${forkedRepoOwner}/${forkedRepo}/forks`)\\n\\t\\t.then(res => {\\n\\t\\t\\treturn res.json()\\n\\t\\t})\\n\\t\\t.then(jsonData => {\\n\\t\\t\\tconst constructedEntries = jsonData.map(entry => {\\n\\t\\t\\t\\treturn constructForkerObject(entry)\\n\\t\\t\\t})\\n\\t\\t\\treturn constructedEntries\\n\\t\\t})\\n\\t\\t.catch(err => {\\n\\t\\t\\tconsole.log('Error ', err)\\n\\t\\t})\\n\\tconst promisedData = await Promise.all(data)\\n\\treturn promisedData\\n}\\n\\nasync function getCommits(baseUrl,users) {\\n\\tconst usersWithCommits = users.map(user => {\\n\\t\\tconst { gitusername, repository } = user\\n\\t\\tconst userWithCommits = fetch(`${baseUrl}/${gitusername}/${repository}/commits?author=${gitusername}`)\\n\\t\\t\\t.then(res => {\\n\\t\\t\\t\\treturn res.json()\\n\\t\\t\\t})\\n\\t\\t\\t.then(jsonData => {\\n\\t\\t\\t\\tuser.commits = jsonData\\n\\t\\t\\t\\treturn user\\n\\t\\t\\t})\\n\\t\\t\\t.catch(err => {\\n\\t\\t\\t\\tconsole.log('Error ', err)\\n\\t\\t\\t})\\n\\t\\treturn userWithCommits\\n\\t})\\n\\tconst promisedData = Promise.all(usersWithCommits)\\n\\treturn promisedData\\n}\\n\\nasync function getIssues(baseUrl, users) {\\n\\tconst usersWithIssues = users.map(user=> {\\n\\t\\tconst { gitusername, repository } = user\\n\\t\\tconst userWithIssues = fetch(`${baseUrl}/${gitusername}/${repository}/issues`)\\n\\t\\t\\t.then(res => {\\n\\t\\t\\t\\treturn res.json()\\n\\t\\t\\t})\\n\\t\\t\\t.then(jsonData => {\\n\\t\\t\\t\\tuser.issues = jsonData\\n\\t\\t\\t\\treturn user\\n\\t\\t\\t})\\n\\t\\t\\t.catch(err => {\\n\\t\\t\\t\\tconsole.log('Error ', err)\\n\\t\\t\\t})\\n\\t\\treturn userWithIssues\\n\\t})\\n\\tconst promisedData = Promise.all(usersWithIssues)\\n\\treturn promisedData\\n}\\n\\nasync function constructForkerObject(entry) {\\n\\tconst forker = new Object()\\n\\tforker.gitusername = entry.owner.login\\n\\tforker.repository = entry.name\\n\\treturn forker\\n}\\n\\n// CONCATENATED MODULE: ./src/js/components/localstorage.js\\nfunction clearStorage() {\\n    window.localStorage.clear()\\n}\\n\\nfunction readStorage(storageItemKey) {\\n    return JSON.parse(window.localStorage.getItem(storageItemKey))\\n}\\n\\nfunction addLocalstorageEntry(item,storagelocation) {\\n\\tconsole.log(JSON.stringify(item))\\n\\tlocalStorage.setItem(storagelocation, JSON.stringify(item))\\n}\\n\\n\\n\\n// CONCATENATED MODULE: ./src/js/components/data.js\\nasync function cleanGithubData(forkersData) {\\n\\tconst cleanedForkers = forkersData.map(async forker => {\\n\\t\\tconst cleanedForker = {}\\n\\t\\tcleanedForker.gitusername = forker.gitusername\\n\\t\\tcleanedForker.repository = forker.repository\\n\\t\\tcleanedForker.commits = await cleanCommits(forker)\\n\\t\\t//cleanedForker.issues = await cleanIssues(forker)\\n\\t\\treturn cleanedForker\\t\\n\\t})\\n\\tconst promisedData = Promise.all(cleanedForkers)\\n\\treturn promisedData\\n}\\n\\nasync function cleanCommits(forker) {\\n\\tconst cleanedCommits = forker.commits.map(commitentry => {\\n\\t\\tconst { commit: { message, committer}, sha, html_url } = commitentry\\n\\t\\tconst splitDate = committer.date.split('T')\\n\\t\\tconst cleanedCommit = {}\\n\\t\\tcleanedCommit.commit = message\\n\\t\\tcleanedCommit.sha = sha\\n\\t\\tcleanedCommit.url = html_url\\n\\t\\tcleanedCommit.pushdate = splitDate[0]\\n\\t\\tcleanedCommit.pushtime = splitDate[1].slice(0,-1)\\n\\t\\treturn cleanedCommit\\n\\t})\\n\\treturn cleanedCommits\\n}\\n\\nasync function cleanIssues(forker) {\\n\\tconst cleanedIssues = forker.issues.map(issueentry => {\\n\\t\\tconst { html_url, created_at, labels, title } = issueentry\\n\\t\\tconst cleanedIssue = {}\\n\\t\\tcleanedIssue.url = html_url\\n\\t\\tcleanedIssue.created_at = created_at\\n\\t\\tcleanedIssue.labels = labels\\n\\t\\tcleanedIssue.title = title\\n\\t\\treturn cleanedIssue\\n\\t})\\n\\treturn  cleanedIssues\\n}\\n\\nasync function sortCommits(forkers) {\\n\\tconst forkersWithSortedCommits = forkers.map(forker => {\\n\\t\\tconst dates = [...new Set(forker.commits.map(commit => {\\n\\t\\t\\treturn commit.pushdate\\n\\t\\t}))]\\n\\t\\tconst sortedCommits = dates.map(date => {\\n\\t\\t\\tconst dateObj = {}\\n\\t\\t\\tdateObj.date = date\\n\\t\\t\\tdateObj.commits = []\\n\\t\\t\\tforker.commits.forEach(commit => {\\n\\t\\t\\t\\tif(date == commit.pushdate) {\\n\\t\\t\\t\\t\\tdateObj.commits.push(commit)\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t\\treturn dateObj\\n\\t\\t})\\n\\t\\tforker.commits = sortedCommits\\n\\t\\treturn forker\\n\\t})\\n\\tconst promisedData = Promise.all(forkersWithSortedCommits)\\n\\treturn promisedData\\n}\\n\\n// CONCATENATED MODULE: ./src/js/virtualdom/createElement.js\\n/* harmony default export */ var createElement = ((tagName, { attrs = {}, children = [] } = {}) => {\\n\\treturn {\\n\\t\\ttagName,\\n\\t\\tattrs,\\n\\t\\tchildren,\\n\\t};\\n});\\n\\n// CONCATENATED MODULE: ./src/js/virtualdom/render.js\\nconst renderElem = ({ tagName, attrs, children}) => {\\n\\t// create the element\\n\\t//   e.g. <div></div>\\n\\tconst $element = document.createElement(tagName);\\n\\n\\t// add all attributs as specified in vNode.attrs\\n\\t//   e.g. <div id=\\\"app\\\"></div>\\n\\tfor (const [key, value] of Object.entries(attrs)) {\\n\\t\\t$element.setAttribute(key, value);\\n\\t}\\n\\n\\t// append all children as specified in vNode.children\\n\\t//   e.g. <div id=\\\"app\\\"><img></div>\\n\\tif(children !== undefined) {\\n\\t\\tfor (const child of children) {\\n\\t\\t\\t$element.appendChild(render(child));\\n\\t\\t}\\n\\t}\\n\\n\\treturn $element;\\n};\\n\\nconst render = (virtualNode) => {\\n\\tif (typeof virtualNode === 'string') {\\n\\t\\treturn document.createTextNode(virtualNode);\\n\\t}\\n\\n\\t// we assume everything else to be a virtual element\\n\\treturn renderElem(virtualNode);\\n};\\n\\n/* harmony default export */ var virtualdom_render = (render);\\n\\n// CONCATENATED MODULE: ./src/js/virtualdom/mount.js\\n/* harmony default export */ var mount = (($node, $target) => {\\n  $target.replaceWith($node)\\n  return $node\\n});\\n\\n// CONCATENATED MODULE: ./src/js/virtualdom/diff.js\\n\\n\\nconst zip = (xs, ys) => {\\n  const zipped = []\\n  for (let i = 0; i < Math.min(xs.length, ys.length); i++) {\\n    zipped.push([xs[i], ys[i]])\\n  }\\n  return zipped\\n}\\n\\nconst diffAttrs = (oldAttrs, newAttrs) => {\\n\\tconst patches = []\\n\\n\\t// Setting newAttributes\\n\\tfor(const [key,value] of Object.entries(newAttrs)) {\\n\\t\\tpatches.push($node => {\\n\\t\\t\\t$node.setAttribute(key,value)\\n\\t\\t\\treturn $node\\n\\t\\t})\\n\\t}\\n\\n\\t// Remove not needed old attributes\\n\\tfor(const key in oldAttrs) {\\n\\t\\tif(!(key in newAttrs)) {\\n\\t\\t\\tpatches.push($node => {\\n\\t\\t\\t\\t$node.removeAttribute(key)\\n\\t\\t\\t\\treturn $node\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\n\\treturn $node => {\\n\\t\\tfor(const patch of patches) {\\n\\t\\t\\tpatch($node)\\n\\t\\t}\\n\\t\\treturn $node\\n\\t}\\n}\\n\\nconst diffChildren = (oldVirtualChildren, newVirtualChildren) => {\\n\\tconst childPatches = []\\n\\toldVirtualChildren.forEach((oldVirtualChildren, i) => {\\n\\t\\tchildPatches.push(diff(oldVirtualChildren, newVirtualChildren[i]))\\n\\t})\\n\\t\\n\\tconst additionalPatches = []\\n\\tfor(const additionalVirtualChild of newVirtualChildren.slice(oldVirtualChildren.length)) {\\n\\t\\tadditionalPatches.push($node => {\\n\\t\\t\\t$node.appendchild(virtualdom_render(newVirtualChildren))\\n\\t\\t\\treturn $node\\n\\t\\t})\\n\\t}\\n\\n\\treturn $parent => {\\n\\t\\tfor (const [patch, $child] of zip(childPatches, $parent.childNodes)) {\\n\\t\\t\\tpatch($child)\\n\\n\\t\\t}\\n\\n\\t\\tfor (const patch of additionalPatches) {\\n\\t\\t\\tpatch($parent);\\n\\t\\t}\\n\\t\\treturn $parent;\\n\\t}\\n}\\n\\nlet diff = (oldVirtualTree, newVirtualTree) => {\\n\\tif(newVirtualTree === undefined) {\\n\\t\\treturn $node => {\\n\\t\\t\\t$node.remove()\\n\\t\\t\\treturn undefined\\n\\t\\t}\\n\\t}\\n\\n\\tif(typeof oldVirtualTree === 'string' || typeof newVirtualTree === 'string') {\\n\\t\\tif(oldVirtualTree !== newVirtualTree) {\\n\\t\\t\\treturn $node => {\\n\\t\\t\\t\\tconst $newNode = virtualdom_render(newVirtualTree)\\n\\t\\t\\t\\t$node.replaceWith($newNode)\\n\\t\\t\\t\\treturn $newNode\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\treturn $node => $node\\n\\t\\t}\\n\\t}\\n\\n\\tif(oldVirtualTree.tagName !== newVirtualTree.tagName) {\\n\\t\\treturn $node => {\\n\\t\\t\\tconst $newNode = virtualdom_render(newVirtualTree)\\n\\t\\t\\t$node.replaceWith($newNode)\\n\\t\\t\\treturn $newNode\\n\\t\\t}\\n\\t}\\n\\n\\tconst patchAttrs = diffAttrs(oldVirtualTree.attrs, newVirtualTree.attrs)\\n\\tconst patchChildren = diffChildren(oldVirtualTree.children, newVirtualTree.children)\\n\\n\\treturn $node => {\\n\\t\\tpatchAttrs($node)\\n\\t\\tpatchChildren($node)\\n\\t\\treturn $node\\n\\t}\\n}\\n\\n/* harmony default export */ var virtualdom_diff = (diff);\\n\\n// CONCATENATED MODULE: ./src/js/components/forkerConstruct.js\\n\\n\\n/* harmony default export */ var forkerConstruct = ((forker) => {\\n\\treturn createElement('section', {\\n\\t\\tattrs: {\\n\\t\\t\\tclass: 'forker__overview__entry'\\n\\t\\t},\\n\\t\\tchildren: [\\n\\t\\t\\tcreateElement('h2', {\\n\\t\\t\\t\\tattrs: {\\n\\t\\t\\t\\t\\tclass: 'title'\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tchildren: [\\n\\t\\t\\t\\t\\tforker.gitusername\\n\\t\\t\\t\\t]\\n\\t\\t\\t}),\\n\\t\\t]\\n\\t})\\n});\\n\\n\\n// CONCATENATED MODULE: ./src/js/app.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\ninit()\\nasync function init() {\\n\\tconst apiSettings = {\\n\\t\\tbaseUrl: 'https://api.github.com/repos',\\n\\t\\tforkedRepoOwner: 'cmda-minor-web',\\n\\t\\tforkedRepo: 'web-app-from-scratch-1920'\\n\\t}\\n\\tconst forkers = await getForkers(apiSettings.baseUrl,apiSettings.forkedRepoOwner,apiSettings.forkedRepo)\\n\\t\\t.then(async (entrys) => {\\n\\t\\t\\treturn await getCommits(apiSettings.baseUrl,entrys)\\n\\t\\t})\\n\\tconsole.log(JSON.stringify(forkers[0],null,4));\\n\\t\\t//.then(async (entrys) => {\\n\\t\\t\\t//return await getIssues(apiSettings.baseUrl,entrys)\\n\\t\\t//})\\n\\tconst cleanedForkers = await cleanGithubData(forkers)\\n\\t\\t.then(async (entrys) => {\\n\\t\\t\\treturn await sortCommits(entrys)\\n\\t\\t})\\n\\t\\n\\n\\troutie_default()({\\n\\t\\t// Default route\\t\\n\\t\\t'': function() {\\n\\t\\t\\tconst constructedForkerChildren = []\\n\\t\\t\\tcleanedForkers.map(forker => {\\n\\t\\t\\t\\tconstructedForkerChildren.push(forkerConstruct(forker))\\n\\t\\t\\t})\\n\\n\\t\\t\\tconst createVirtualApp = () => createElement('main', {\\n\\t\\t\\t\\tattrs: {\\n\\t\\t\\t\\t\\tid: 'app',\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tchildren: [\\n\\t\\t\\t\\t\\tcreateElement('section', {\\n\\t\\t\\t\\t\\t\\tattrs: {\\n\\t\\t\\t\\t\\t\\t\\tclass: 'forkers__overview'\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\tchildren: constructedForkerChildren\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t],\\n\\t\\t\\t});\\n\\t\\t\\tlet count = 0;\\n\\t\\t\\tconst virtualApp = createVirtualApp();\\n\\t\\t\\tconst $app = virtualdom_render(virtualApp);\\n\\t\\t\\tlet $rootElement = mount($app, document.getElementById('app'));\\n\\n\\t\\t\\t//setInterval(() => {\\n\\t\\t\\t\\t//count++;\\n\\t\\t\\t\\t//const virtualNewApp = createVirtualApp(count)\\n\\t\\t\\t\\t//const patch = diff(virtualApp, virtualNewApp)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//$rootElement = patch($rootElement)\\n\\t\\t\\t\\t//console.log($rootElement);\\n\\t\\t\\t//}, 1000);\\n\\t\\t},\\n\\t\\t'home': function() {\\n\\t\\t\\tconsole.log('SUP HOME')\\n\\t\\t},\\n\\t\\t'about': function() {\\n\\t\\t\\tconsole.log('Sup ABOUT')\\n\\t\\t}\\n\\t})\\n}\\n\\n// CONCATENATED MODULE: ./src/index.js\\n// Import custom js files here\\n\\n\\n\\n\\n\\n//# sourceURL=webpack:///./src/index.js_+_9_modules?\")}]);","extractedComments":[]}